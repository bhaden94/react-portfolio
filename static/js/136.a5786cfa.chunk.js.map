{"version":3,"file":"static/js/136.a5786cfa.chunk.js","mappings":"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","sources":["../node_modules/sanity/src/structure/components/paneRouter/PaneRouterProvider.tsx","../node_modules/sanity/src/structure/structureResolvers/PaneResolutionError.ts","../node_modules/sanity/src/structure/structureResolvers/assignId.ts","../node_modules/sanity/src/structure/structureResolvers/createPaneResolver.ts","../node_modules/sanity/src/structure/structureResolvers/memoBind.ts","../node_modules/sanity/src/structure/structureResolvers/createResolvedPaneNodeStream.ts","../node_modules/rxjs/src/internal/operators/pairwise.ts","../node_modules/sanity/src/structure/structureResolvers/useResolvedPanes.ts","../node_modules/sanity/src/structure/components/structureTool/intentResolver/IntentResolver.tsx","../node_modules/sanity/src/structure/components/structureTool/intentResolver/utils.ts","../node_modules/sanity/src/structure/structureResolvers/resolveIntent.ts","../node_modules/sanity/src/structure/components/structureTool/StructureError.tsx","../node_modules/sanity/src/structure/panes/unknown/UnknownPaneType.tsx","../node_modules/sanity/src/structure/panes/StructureToolPane.tsx","../node_modules/sanity/src/structure/components/structureTool/NoDocumentTypesScreen.tsx","../node_modules/sanity/src/structure/components/structureTool/StructureTitle.tsx","../node_modules/sanity/src/structure/components/structureTool/StructureTool.tsx","../node_modules/sanity/src/structure/components/structureTool/StructureToolBoundary.tsx"],"sourcesContent":["import {toString as pathToString} from '@sanity/util/paths'\nimport {omit} from 'lodash'\nimport {type ReactNode, useCallback, useMemo} from 'react'\nimport {PaneRouterContext} from 'sanity/_singletons'\nimport {useRouter, useRouterState} from 'sanity/router'\n\nimport {type RouterPaneGroup, type RouterPanes, type RouterPaneSibling} from '../../types'\nimport {usePaneLayout} from '../pane/usePaneLayout'\nimport {BackLink} from './BackLink'\nimport {ChildLink} from './ChildLink'\nimport {ParameterizedLink} from './ParameterizedLink'\nimport {ReferenceChildLink} from './ReferenceChildLink'\nimport {type PaneRouterContextValue} from './types'\n\nconst emptyArray: never[] = []\n\n/**\n * @internal\n */\nexport function PaneRouterProvider(props: {\n  children: ReactNode\n  flatIndex: number\n  index: number\n  params: Record<string, string | undefined>\n  payload: unknown\n  siblingIndex: number\n}) {\n  const {children, flatIndex, index, params, payload, siblingIndex} = props\n  const {navigate, navigateIntent, resolvePathFromState} = useRouter()\n  const routerState = useRouterState()\n  const {panes, expand} = usePaneLayout()\n  const routerPaneGroups: RouterPaneGroup[] = useMemo(\n    () => (routerState?.panes || emptyArray) as RouterPanes,\n    [routerState?.panes],\n  )\n  const lastPane = useMemo(() => panes?.[panes.length - 2], [panes])\n\n  const groupIndex = index - 1\n\n  const createNextRouterState = useCallback(\n    (modifier: (siblings: RouterPaneGroup, item: RouterPaneSibling) => RouterPaneGroup) => {\n      const currentGroup = routerPaneGroups[groupIndex] || []\n      const currentItem = currentGroup[siblingIndex]\n      const nextGroup = modifier(currentGroup, currentItem)\n      const nextPanes = [\n        ...routerPaneGroups.slice(0, groupIndex),\n        nextGroup,\n        ...routerPaneGroups.slice(groupIndex + 1),\n      ]\n      const nextRouterState = {...(routerState || {}), panes: nextPanes}\n\n      return nextRouterState\n    },\n    [groupIndex, routerPaneGroups, routerState, siblingIndex],\n  )\n\n  const modifyCurrentGroup = useCallback(\n    (modifier: (siblings: RouterPaneGroup, item: RouterPaneSibling) => RouterPaneGroup) => {\n      const nextRouterState = createNextRouterState(modifier)\n      setTimeout(() => navigate(nextRouterState), 0)\n      return nextRouterState\n    },\n    [createNextRouterState, navigate],\n  )\n\n  const createPathWithParams: PaneRouterContextValue['createPathWithParams'] = useCallback(\n    (nextParams) => {\n      const nextRouterState = createNextRouterState((siblings, item) => [\n        ...siblings.slice(0, siblingIndex),\n        {...item, params: nextParams},\n        ...siblings.slice(siblingIndex + 1),\n      ])\n\n      return resolvePathFromState(nextRouterState)\n    },\n    [createNextRouterState, resolvePathFromState, siblingIndex],\n  )\n\n  const setPayload: PaneRouterContextValue['setPayload'] = useCallback(\n    (nextPayload) => {\n      modifyCurrentGroup((siblings, item) => [\n        ...siblings.slice(0, siblingIndex),\n        {...item, payload: nextPayload},\n        ...siblings.slice(siblingIndex + 1),\n      ])\n    },\n    [modifyCurrentGroup, siblingIndex],\n  )\n\n  const setParams: PaneRouterContextValue['setParams'] = useCallback(\n    (nextParams) => {\n      modifyCurrentGroup((siblings, item) => [\n        ...siblings.slice(0, siblingIndex),\n        {...item, params: nextParams},\n        ...siblings.slice(siblingIndex + 1),\n      ])\n    },\n    [modifyCurrentGroup, siblingIndex],\n  )\n\n  const handleEditReference: PaneRouterContextValue['handleEditReference'] = useCallback(\n    ({id, parentRefPath, type, template}) => {\n      navigate({\n        panes: [\n          ...routerPaneGroups.slice(0, groupIndex + 1),\n          [\n            {\n              id,\n              params: {template: template.id, parentRefPath: pathToString(parentRefPath), type},\n              payload: template.params,\n            },\n          ],\n        ],\n      })\n    },\n    [groupIndex, navigate, routerPaneGroups],\n  )\n\n  const ctx: PaneRouterContextValue = useMemo(\n    () => ({\n      // Zero-based index (position) of pane, visually\n      index: flatIndex,\n\n      // Zero-based index of pane group (within URL structure)\n      groupIndex,\n\n      // Zero-based index of pane within sibling group\n      siblingIndex,\n\n      // Payload of the current pane\n      payload,\n\n      // Params of the current pane\n      params,\n\n      // Whether or not the pane has any siblings (within the same group)\n      hasGroupSiblings: routerPaneGroups[groupIndex]\n        ? routerPaneGroups[groupIndex].length > 1\n        : false,\n\n      // The length of the current group\n      groupLength: routerPaneGroups[groupIndex] ? routerPaneGroups[groupIndex].length : 0,\n\n      // Current router state for the \"panes\" property\n      routerPanesState: routerPaneGroups,\n\n      // Curried StateLink that passes the correct state automatically\n      ChildLink,\n\n      // Curried StateLink that pops off the last pane group\n      // Only pass if this is not the first pane\n      BackLink: flatIndex ? BackLink : undefined,\n\n      // A specialized `ChildLink` that takes in the needed props to open a\n      // referenced document to the right\n      ReferenceChildLink,\n\n      // Similar to `ReferenceChildLink` expect without the wrapping component\n      handleEditReference,\n\n      // Curried StateLink that passed the correct state, but merges params/payload\n      ParameterizedLink,\n\n      // Replaces the current pane with a new one\n      replaceCurrent: (opts = {}): void => {\n        modifyCurrentGroup(() => [\n          {id: opts.id || '', payload: opts.payload, params: opts.params || {}},\n        ])\n      },\n\n      // Removes the current pane from the group\n      closeCurrent: (): void => {\n        modifyCurrentGroup((siblings, item) =>\n          siblings.length > 1 ? siblings.filter((sibling) => sibling !== item) : siblings,\n        )\n      },\n\n      // Removes all panes to the right including current\n      closeCurrentAndAfter: (expandLast = true): void => {\n        if (expandLast && lastPane) {\n          expand(lastPane.element)\n        }\n        navigate(\n          {\n            panes: [...routerPaneGroups.slice(0, groupIndex)],\n          },\n          {replace: true},\n        )\n      },\n\n      // Duplicate the current pane, with optional overrides for payload, parameters\n      duplicateCurrent: (options): void => {\n        modifyCurrentGroup((siblings, item) => {\n          const duplicatedItem = {\n            ...item,\n            payload: options?.payload || item.payload,\n            params: options?.params || item.params,\n          }\n\n          return [\n            ...siblings.slice(0, siblingIndex),\n            duplicatedItem,\n            ...siblings.slice(siblingIndex),\n          ]\n        })\n      },\n\n      // Set the view for the current pane\n      setView: (viewId) => {\n        const restParams = omit(params, 'view')\n        return setParams(viewId ? {...restParams, view: viewId} : restParams)\n      },\n\n      // Set the parameters for the current pane\n      setParams,\n\n      // Set the payload for the current pane\n      setPayload,\n\n      // A function that returns a path with the given parameters\n      createPathWithParams,\n\n      // Proxied navigation to a given intent. Consider just exposing `router` instead?\n      navigateIntent,\n    }),\n    [\n      flatIndex,\n      groupIndex,\n      siblingIndex,\n      payload,\n      params,\n      routerPaneGroups,\n      handleEditReference,\n      setParams,\n      setPayload,\n      createPathWithParams,\n      navigateIntent,\n      modifyCurrentGroup,\n      lastPane,\n      navigate,\n      expand,\n    ],\n  )\n\n  return <PaneRouterContext.Provider value={ctx}>{children}</PaneRouterContext.Provider>\n}\n","import {type RouterPaneSiblingContext} from '../types'\n\nexport interface PaneResolutionErrorOptions {\n  message: string\n  context?: RouterPaneSiblingContext\n  helpId?: string\n  cause?: Error\n}\n\n/**\n * An error thrown during pane resolving. This error is meant to be bubbled up\n * through react and handled in an error boundary. It includes a `cause`\n * property which is the original error caught\n */\nexport class PaneResolutionError extends Error {\n  cause: Error | undefined\n  context: RouterPaneSiblingContext | undefined\n  helpId: string | undefined\n\n  constructor({message, context, helpId, cause}: PaneResolutionErrorOptions) {\n    super(message)\n    this.name = 'PaneResolutionError'\n    this.context = context\n    this.helpId = helpId\n    this.cause = cause\n  }\n}\n","import {nanoid} from 'nanoid'\n\n// `WeakMap`s require the first type param to extend `object`\n// eslint-disable-next-line @typescript-eslint/ban-types\nconst randomIdCache = new WeakMap<object, string>()\n\n/**\n * given an object, this function randomly generates an ID and returns it. this\n * result is then saved in a WeakMap so subsequent requests for the same object\n * will receive the same ID\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function assignId(obj: object): string {\n  const cachedValue = randomIdCache.get(obj)\n  if (cachedValue) return cachedValue\n\n  const id = nanoid()\n  randomIdCache.set(obj, id)\n  return id\n}\n","import {from, isObservable, type Observable, of as observableOf} from 'rxjs'\nimport {publishReplay, refCount, switchMap} from 'rxjs/operators'\nimport {isRecord} from 'sanity'\n\nimport {type PaneNode, type RouterPaneSiblingContext, type UnresolvedPaneNode} from '../types'\nimport {PaneResolutionError} from './PaneResolutionError'\n\ninterface Serializable {\n  serialize: (...args: never[]) => unknown\n}\n\nconst isPromise = (thing: any): thing is PromiseLike<unknown> => {\n  return !!thing && typeof thing?.then === 'function'\n}\nconst isSerializable = (thing: unknown): thing is Serializable => {\n  if (!isRecord(thing)) return false\n  return typeof thing.serialize === 'function'\n}\n\n/**\n * The signature of the function used to take an `UnresolvedPaneNode` and turn\n * it into an `Observable<PaneNode>`.\n */\nexport type PaneResolver = (\n  unresolvedPane: UnresolvedPaneNode | undefined,\n  context: RouterPaneSiblingContext,\n  flatIndex: number,\n) => Observable<PaneNode>\n\nexport type PaneResolverMiddleware = (paneResolveFn: PaneResolver) => PaneResolver\n\nconst rethrowWithPaneResolutionErrors: PaneResolverMiddleware =\n  (next) => (unresolvedPane, context, flatIndex) => {\n    try {\n      return next(unresolvedPane, context, flatIndex)\n    } catch (e) {\n      // re-throw errors that are already `PaneResolutionError`s\n      if (e instanceof PaneResolutionError) {\n        throw e\n      }\n\n      // anything else, wrap with `PaneResolutionError` and set the underlying\n      // error as a the `cause`\n      throw new PaneResolutionError({\n        message: typeof e?.message === 'string' ? e.message : '',\n        context,\n        cause: e,\n      })\n    }\n  }\n\nconst wrapWithPublishReplay: PaneResolverMiddleware =\n  (next) =>\n  (...args) => {\n    return next(...args).pipe(\n      // need to add publishReplay + refCount to ensure new subscribers always\n      // get an emission. without this, memoized observables may get stuck\n      // waiting for their first emissions resulting in a loading pane\n      publishReplay(1),\n      refCount(),\n    )\n  }\n\nexport function createPaneResolver(middleware: PaneResolverMiddleware): PaneResolver {\n  // note: this API includes a middleware/wrapper function because the function\n  // is recursive. we want to call the wrapped version of the function always\n  // (even inside of nested calls) so the identifier invoked for the recursion\n  // should be the wrapped version\n  const resolvePane = rethrowWithPaneResolutionErrors(\n    wrapWithPublishReplay(\n      middleware((unresolvedPane, context, flatIndex) => {\n        if (!unresolvedPane) {\n          throw new PaneResolutionError({\n            message: 'Pane returned no child',\n            context,\n            helpId: 'structure-item-returned-no-child',\n          })\n        }\n\n        if (isPromise(unresolvedPane) || isObservable(unresolvedPane)) {\n          return from(unresolvedPane).pipe(\n            switchMap((result) => resolvePane(result, context, flatIndex)),\n          )\n        }\n\n        if (isSerializable(unresolvedPane)) {\n          return resolvePane(unresolvedPane.serialize(context), context, flatIndex)\n        }\n\n        if (typeof unresolvedPane === 'function') {\n          return resolvePane(unresolvedPane(context.id, context), context, flatIndex)\n        }\n\n        return observableOf(unresolvedPane)\n      }),\n    ),\n  )\n\n  return resolvePane\n}\n","/* eslint-disable @typescript-eslint/ban-types */\n\n// `WeakMap`s require the first type param to extend `object`\nconst bindCache = new WeakMap<object, Map<string, Function>>()\n\n/**\n * An alternative to `obj.method.bind(obj)` that utilizes a weakmap to return\n * the same memory reference for sequent binds.\n */\nexport function memoBind<\n  T extends object,\n  K extends keyof {[P in keyof T]: T[P] extends Function ? T[P] : never},\n>(obj: T, methodKey: K): T[K]\nexport function memoBind(obj: Record<string, unknown>, methodKey: string): Function {\n  const boundMethods = bindCache.get(obj) || new Map<string, Function>()\n  if (boundMethods) {\n    const bound = boundMethods.get(methodKey)\n    if (bound) return bound\n  }\n\n  const method = obj[methodKey]\n\n  if (typeof method !== 'function') {\n    throw new Error(\n      `Expected property \\`${methodKey}\\` to be a function but got ${typeof method} instead.`,\n    )\n  }\n\n  const bound = method.bind(obj)\n  boundMethods.set(methodKey, bound)\n  bindCache.set(obj, boundMethods)\n\n  return bound\n}\n","import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {isEqual} from 'lodash'\nimport {concat, NEVER, type Observable, of as observableOf} from 'rxjs'\nimport {distinctUntilChanged, map, pairwise, scan, startWith, switchMap} from 'rxjs/operators'\n\nimport {type StructureContext} from '../structureBuilder'\nimport {\n  type DocumentPaneNode,\n  type PaneNode,\n  type PaneNodeResolver,\n  type RouterPanes,\n  type RouterPaneSibling,\n  type RouterPaneSiblingContext,\n  type UnresolvedPaneNode,\n} from '../types'\nimport {assignId} from './assignId'\nimport {\n  createPaneResolver,\n  type PaneResolver,\n  type PaneResolverMiddleware,\n} from './createPaneResolver'\nimport {memoBind} from './memoBind'\nimport {PaneResolutionError} from './PaneResolutionError'\n\n/**\n * the fallback editor child that is implicitly inserted into the structure tree\n * if the id starts with `__edit__`\n */\nconst fallbackEditorChild: PaneNodeResolver = (nodeId, context): DocumentPaneNode => {\n  const id = nodeId.replace(/^__edit__/, '')\n  const {\n    params,\n    payload,\n    structureContext: {resolveDocumentNode},\n  } = context\n  const {type, template} = params\n\n  if (!type) {\n    throw new Error(\n      `Document type for document with ID ${id} was not provided in the router params.`,\n    )\n  }\n\n  let defaultDocumentBuilder = resolveDocumentNode({schemaType: type, documentId: id}).id('editor')\n\n  if (template) {\n    defaultDocumentBuilder = defaultDocumentBuilder.initialValueTemplate(\n      template,\n      payload as {[key: string]: unknown},\n    )\n  }\n\n  return defaultDocumentBuilder.serialize() as DocumentPaneNode\n}\n\n/**\n * takes in a `RouterPaneSiblingContext` and returns a normalized string\n * representation that can be used for comparisons\n */\nfunction hashContext(context: RouterPaneSiblingContext): string {\n  return `contextHash(${JSON.stringify({\n    id: context.id,\n    parentId: parent && assignId(parent),\n    path: context.path,\n    index: context.index,\n    splitIndex: context.splitIndex,\n    serializeOptionsIndex: context.serializeOptions?.index,\n    serializeOptionsPath: context.serializeOptions?.path,\n  })})`\n}\n\n/**\n * takes in `ResolvedPaneMeta` and returns a normalized string representation\n * that can be used for comparisons\n */\nconst hashResolvedPaneMeta = (meta: ResolvedPaneMeta): string => {\n  const normalized = {\n    type: meta.type,\n    id: meta.routerPaneSibling.id,\n    params: meta.routerPaneSibling.params || {},\n    payload: meta.routerPaneSibling.payload || null,\n    flatIndex: meta.flatIndex,\n    groupIndex: meta.groupIndex,\n    siblingIndex: meta.siblingIndex,\n    path: meta.path,\n    paneNode: meta.type === 'resolvedMeta' ? assignId(meta.paneNode) : null,\n  }\n\n  return `metaHash(${JSON.stringify(normalized)})`\n}\n\n/**\n * Represents one flattened \"router pane\", including the source group and\n * sibling indexes.\n *\n * @see RouterPanes\n */\ninterface FlattenedRouterPane {\n  routerPaneSibling: RouterPaneSibling\n  flatIndex: number\n  groupIndex: number\n  siblingIndex: number\n}\n\n/**\n * The state of the accumulator used to store and manage memo cache state\n */\ninterface CacheState {\n  /**\n   * Holds the memoization results keyed by a combination of `assignId` and a\n   * context hash.\n   */\n  resolvedPaneCache: Map<string, Observable<PaneNode>>\n  /**\n   * Acts as a dictionary that stores cache keys by their flat index. This is\n   * used to clean up the cache between different branches in the pane\n   * structure.\n   *\n   * @see createResolvedPaneNodeStream look inside the `scan` where `wrapFn` is\n   * defined\n   */\n  cacheKeysByFlatIndex: Array<Set<string>>\n  /**\n   * The resulting memoized `PaneResolver` function. This function closes over\n   * the `resolvedPaneCache`.\n   */\n  resolvePane: PaneResolver\n  flattenedRouterPanes: FlattenedRouterPane[]\n}\n\nexport interface CreateResolvedPaneNodeStreamOptions {\n  /**\n   * an input stream of `RouterPanes`\n   * @see RouterPanes\n   */\n  routerPanesStream: Observable<RouterPanes>\n  /**\n   * any `UnresolvedPaneNode` (could be an observable, promise, pane resolver etc)\n   */\n  rootPaneNode: UnresolvedPaneNode\n  /** used primarily for testing */\n  initialCacheState?: CacheState\n\n  structureContext: StructureContext\n}\n\n/**\n * The result of pane resolving\n */\nexport type ResolvedPaneMeta = {\n  groupIndex: number\n  siblingIndex: number\n  flatIndex: number\n  routerPaneSibling: RouterPaneSibling\n  path: string[]\n} & ({type: 'loading'; paneNode: null} | {type: 'resolvedMeta'; paneNode: PaneNode})\n\ninterface ResolvePaneTreeOptions {\n  resolvePane: PaneResolver\n  flattenedRouterPanes: FlattenedRouterPane[]\n  unresolvedPane: UnresolvedPaneNode | undefined\n  parent: PaneNode | null\n  path: string[]\n  structureContext: StructureContext\n}\n\n/**\n * A recursive pane resolving function. Starts at one unresolved pane node and\n * continues until there is no more flattened router panes that can be used as\n * input to the unresolved panes.\n */\nfunction resolvePaneTree({\n  unresolvedPane,\n  flattenedRouterPanes,\n  parent,\n  path,\n  resolvePane,\n  structureContext,\n}: ResolvePaneTreeOptions): Observable<ResolvedPaneMeta[]> {\n  const [current, ...rest] = flattenedRouterPanes\n  const next = rest[0] as FlattenedRouterPane | undefined\n\n  const context: RouterPaneSiblingContext = {\n    id: current.routerPaneSibling.id,\n    splitIndex: current.siblingIndex,\n    parent,\n    path: [...path, current.routerPaneSibling.id],\n    index: current.flatIndex,\n    params: current.routerPaneSibling.params || {},\n    payload: current.routerPaneSibling.payload,\n    structureContext,\n  }\n\n  try {\n    return resolvePane(unresolvedPane, context, current.flatIndex).pipe(\n      // this switch map receives a resolved pane\n      switchMap((paneNode) => {\n        // we can create a `resolvedMeta` type using it\n        const resolvedPaneMeta: ResolvedPaneMeta = {\n          type: 'resolvedMeta',\n          ...current,\n          paneNode: paneNode,\n          path: context.path,\n        }\n\n        // for the other unresolved panes, we can create \"loading panes\"\n        const loadingPanes = rest.map((i, restIndex) => {\n          const loadingPanePath = [\n            ...context.path,\n            ...rest.slice(restIndex).map((_, currentIndex) => `[${i.flatIndex + currentIndex}]`),\n          ]\n\n          const loadingPane: ResolvedPaneMeta = {\n            type: 'loading',\n            path: loadingPanePath,\n            paneNode: null,\n            ...i,\n          }\n\n          return loadingPane\n        })\n\n        if (!rest.length) {\n          return observableOf([resolvedPaneMeta])\n        }\n\n        let nextStream\n\n        if (\n          // the fallback editor case\n          next?.routerPaneSibling.id.startsWith('__edit__')\n        ) {\n          nextStream = resolvePaneTree({\n            unresolvedPane: fallbackEditorChild,\n            flattenedRouterPanes: rest,\n            parent,\n            path: context.path,\n            resolvePane,\n            structureContext,\n          })\n        } else if (current.groupIndex === next?.groupIndex) {\n          // if the next flattened router pane has the same group index as the\n          // current flattened router pane, then the next flattened router pane\n          // belongs to the same group (i.e. it is a split pane)\n          nextStream = resolvePaneTree({\n            unresolvedPane,\n            flattenedRouterPanes: rest,\n            parent,\n            path,\n            resolvePane,\n            structureContext,\n          })\n        } else {\n          // normal children resolving\n          nextStream = resolvePaneTree({\n            unresolvedPane:\n              typeof paneNode.child === 'function'\n                ? (memoBind(paneNode, 'child') as PaneNodeResolver)\n                : paneNode.child,\n            flattenedRouterPanes: rest,\n            parent: paneNode,\n            path: context.path,\n            resolvePane,\n            structureContext,\n          })\n        }\n\n        return concat(\n          // we emit the loading panes first in a concat (this emits immediately)\n          observableOf([resolvedPaneMeta, ...loadingPanes]),\n          // then whenever the next stream is done, the results will be combined.\n          nextStream.pipe(map((nextResolvedPanes) => [resolvedPaneMeta, ...nextResolvedPanes])),\n        )\n      }),\n    )\n  } catch (e) {\n    if (e instanceof PaneResolutionError) {\n      if (e.context) {\n        console.warn(\n          `Pane resolution error at index ${e.context.index}${\n            e.context.splitIndex > 0 ? ` for split pane index ${e.context.splitIndex}` : ''\n          }: ${e.message}${e.helpId ? ` - see ${generateHelpUrl(e.helpId)}` : ''}`,\n          e,\n        )\n      }\n\n      if (e.helpId === 'structure-item-returned-no-child') {\n        // returning an observable of an empty array will remove loading panes\n        // note: this one intentionally does not throw\n        return observableOf([])\n      }\n    }\n\n    throw e\n  }\n}\n\n/**\n * Takes in a stream of `RouterPanes` and an unresolved root pane and returns\n * a stream of `ResolvedPaneMeta`\n */\nexport function createResolvedPaneNodeStream({\n  routerPanesStream,\n  rootPaneNode,\n  initialCacheState = {\n    cacheKeysByFlatIndex: [],\n    flattenedRouterPanes: [],\n    resolvedPaneCache: new Map(),\n    resolvePane: () => NEVER,\n  },\n  structureContext,\n}: CreateResolvedPaneNodeStreamOptions): Observable<ResolvedPaneMeta[]> {\n  const resolvedPanes$ = routerPanesStream.pipe(\n    // add in implicit \"root\" router pane\n    map((rawRouterPanes) => [[{id: 'root'}], ...rawRouterPanes]),\n    // create flattened router panes\n    map((routerPanes) => {\n      const flattenedRouterPanes: FlattenedRouterPane[] = routerPanes\n        .flatMap((routerPaneGroup, groupIndex) =>\n          routerPaneGroup.map((routerPaneSibling, siblingIndex) => ({\n            routerPaneSibling,\n            groupIndex,\n            siblingIndex,\n          })),\n        )\n        // add in the flat index\n        .map((i, index) => ({...i, flatIndex: index}))\n\n      return flattenedRouterPanes\n    }),\n    // calculate a \"diffIndex\" used for clearing the memo cache\n    startWith([] as FlattenedRouterPane[]),\n    pairwise(),\n    map(([prev, curr]) => {\n      for (let i = 0; i < curr.length; i++) {\n        const prevValue = prev[i]\n        const currValue = curr[i]\n\n        if (!isEqual(prevValue, currValue)) {\n          return {\n            flattenedRouterPanes: curr,\n            diffIndex: i,\n          }\n        }\n      }\n\n      return {\n        flattenedRouterPanes: curr,\n        diffIndex: curr.length,\n      }\n    }),\n    // create the memoized `resolvePane` function and manage the memo cache\n    scan((acc, next) => {\n      const {cacheKeysByFlatIndex, resolvedPaneCache} = acc\n      const {flattenedRouterPanes, diffIndex} = next\n\n      // use the `cacheKeysByFlatIndex` like a dictionary to find cache keys to\n      // and cache keys to delete\n      const beforeDiffIndex = cacheKeysByFlatIndex.slice(0, diffIndex + 1)\n      const afterDiffIndex = cacheKeysByFlatIndex.slice(diffIndex + 1)\n\n      const keysToKeep = new Set(beforeDiffIndex.flatMap((keySet) => Array.from(keySet)))\n      const keysToDelete = afterDiffIndex\n        .flatMap((keySet) => Array.from(keySet))\n        .filter((key) => !keysToKeep.has(key))\n\n      for (const key of keysToDelete) {\n        resolvedPaneCache.delete(key)\n      }\n\n      // create a memoizing pane resolver middleware that utilizes the cache\n      // maintained above. this keeps the cache from growing indefinitely\n      const memoize: PaneResolverMiddleware = (nextFn) => (unresolvedPane, context, flatIndex) => {\n        const key = unresolvedPane && `${assignId(unresolvedPane)}-${hashContext(context)}`\n        const cachedResolvedPane = key && resolvedPaneCache.get(key)\n        if (cachedResolvedPane) return cachedResolvedPane\n\n        const result = nextFn(unresolvedPane, context, flatIndex)\n        if (!key) return result\n\n        const cacheKeySet = cacheKeysByFlatIndex[flatIndex] || new Set()\n        cacheKeySet.add(key)\n        cacheKeysByFlatIndex[flatIndex] = cacheKeySet\n        resolvedPaneCache.set(key, result)\n        return result\n      }\n\n      return {\n        flattenedRouterPanes,\n        cacheKeysByFlatIndex,\n        resolvedPaneCache,\n        resolvePane: createPaneResolver(memoize),\n      }\n    }, initialCacheState),\n    // run the memoized, recursive resolving\n    switchMap(({flattenedRouterPanes, resolvePane}) =>\n      resolvePaneTree({\n        unresolvedPane: rootPaneNode,\n        flattenedRouterPanes,\n        parent: null,\n        path: [],\n        resolvePane,\n        structureContext,\n      }),\n    ),\n  )\n\n  // after we've created a stream of `ResolvedPaneMeta[]`, we need to clean up\n  // the results to remove unwanted loading panes and prevent unnecessary\n  // emissions\n  return resolvedPanes$.pipe(\n    // this diffs the previous emission with the current one. if there is a new\n    // loading pane at the same position where a previous pane already had a\n    // resolved value (looking at the IDs to compare), then return the previous\n    // pane instead of the loading pane\n    scan(\n      (prev, next) =>\n        next.map((nextPane, index) => {\n          const prevPane = prev[index] as ResolvedPaneMeta | undefined\n          if (!prevPane) return nextPane\n          if (nextPane.type !== 'loading') return nextPane\n\n          if (prevPane.routerPaneSibling.id === nextPane.routerPaneSibling.id) {\n            return prevPane\n          }\n          return nextPane\n        }),\n      [] as ResolvedPaneMeta[],\n    ),\n    // this prevents duplicate emissions\n    distinctUntilChanged((prev, next) => {\n      if (prev.length !== next.length) return false\n\n      for (let i = 0; i < next.length; i++) {\n        const prevValue = prev[i]\n        const nextValue = next[i]\n        if (hashResolvedPaneMeta(prevValue) !== hashResolvedPaneMeta(nextValue)) {\n          return false\n        }\n      }\n\n      return true\n    }),\n  )\n}\n","import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Groups pairs of consecutive emissions together and emits them as an array of\n * two values.\n *\n * <span class=\"informal\">Puts the current value and previous value together as\n * an array, and emits that.</span>\n *\n * ![](pairwise.png)\n *\n * The Nth emission from the source Observable will cause the output Observable\n * to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n * pair. For this reason, `pairwise` emits on the second and subsequent\n * emissions from the source Observable, but not on the first emission, because\n * there is no previous value in that case.\n *\n * ## Example\n *\n * On every click (starting from the second), emit the relative distance to the previous click\n *\n * ```ts\n * import { fromEvent, pairwise, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const pairs = clicks.pipe(pairwise());\n * const distance = pairs.pipe(\n *   map(([first, second]) => {\n *     const x0 = first.clientX;\n *     const y0 = first.clientY;\n *     const x1 = second.clientX;\n *     const y1 = second.clientY;\n *     return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n *   })\n * );\n *\n * distance.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link buffer}\n * @see {@link bufferCount}\n *\n * @return A function that returns an Observable of pairs (as arrays) of\n * consecutive values from the source Observable.\n */\nexport function pairwise<T>(): OperatorFunction<T, [T, T]> {\n  return operate((source, subscriber) => {\n    let prev: T;\n    let hasPrev = false;\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value) => {\n        const p = prev;\n        prev = value;\n        hasPrev && subscriber.next([p, value]);\n        hasPrev = true;\n      })\n    );\n  });\n}\n","import {useEffect, useMemo, useState} from 'react'\nimport {ReplaySubject} from 'rxjs'\nimport {map} from 'rxjs/operators'\nimport {type RouterState, useRouter} from 'sanity/router'\n\nimport {LOADING_PANE} from '../constants'\nimport {type PaneNode, type RouterPaneGroup, type RouterPanes} from '../types'\nimport {useStructureTool} from '../useStructureTool'\nimport {createResolvedPaneNodeStream} from './createResolvedPaneNodeStream'\n\ninterface PaneData {\n  active: boolean\n  childItemId: string | null\n  groupIndex: number\n  index: number\n  itemId: string\n  key: string\n  pane: PaneNode | typeof LOADING_PANE\n  params: Record<string, string | undefined>\n  path: string\n  payload: unknown\n  selected: boolean\n  siblingIndex: number\n}\n\nexport interface Panes {\n  paneDataItems: PaneData[]\n  routerPanes: RouterPanes\n  resolvedPanes: (PaneNode | typeof LOADING_PANE)[]\n}\n\nfunction useRouterPanesStream() {\n  const routerStateSubject = useMemo(() => new ReplaySubject<RouterState>(1), [])\n  const routerPanes$ = useMemo(\n    () =>\n      routerStateSubject\n        .asObservable()\n        .pipe(map((_routerState) => (_routerState?.panes || []) as RouterPanes)),\n    [routerStateSubject],\n  )\n  const {state: routerState} = useRouter()\n  useEffect(() => {\n    routerStateSubject.next(routerState)\n  }, [routerState, routerStateSubject])\n\n  return routerPanes$\n}\n\nexport function useResolvedPanes(): Panes {\n  // used to propagate errors from async effect. throwing inside of the render\n  // will bubble the error to react where it can be picked up by standard error\n  // boundaries\n  const [error, setError] = useState<unknown>()\n  if (error) throw error\n\n  const {structureContext, rootPaneNode} = useStructureTool()\n\n  const [data, setData] = useState<Panes>({\n    paneDataItems: [],\n    resolvedPanes: [],\n    routerPanes: [],\n  })\n\n  const routerPanesStream = useRouterPanesStream()\n\n  useEffect(() => {\n    const resolvedPanes$ = createResolvedPaneNodeStream({\n      rootPaneNode,\n      routerPanesStream,\n      structureContext,\n    }).pipe(\n      map((resolvedPanes) => {\n        const routerPanes = resolvedPanes.reduce<RouterPanes>((acc, next) => {\n          const currentGroup = acc[next.groupIndex] || []\n          currentGroup[next.siblingIndex] = next.routerPaneSibling\n          acc[next.groupIndex] = currentGroup\n          return acc\n        }, [])\n\n        const groupsLen = routerPanes.length\n\n        const paneDataItems = resolvedPanes.map((pane) => {\n          const {groupIndex, flatIndex, siblingIndex, routerPaneSibling, path} = pane\n          const itemId = routerPaneSibling.id\n          const nextGroup = routerPanes[groupIndex + 1] as RouterPaneGroup | undefined\n\n          const paneDataItem: PaneData = {\n            active: groupIndex === groupsLen - 2,\n            childItemId: nextGroup?.[0].id ?? null,\n            index: flatIndex,\n            itemId: routerPaneSibling.id,\n            groupIndex,\n            key: `${\n              pane.type === 'loading' ? 'unknown' : pane.paneNode.id\n            }-${itemId}-${siblingIndex}`,\n            pane: pane.type === 'loading' ? LOADING_PANE : pane.paneNode,\n            params: routerPaneSibling.params || {},\n            path: path.join(';'),\n            payload: routerPaneSibling.payload,\n            selected: flatIndex === resolvedPanes.length - 1,\n            siblingIndex,\n          }\n\n          return paneDataItem\n        })\n\n        return {\n          paneDataItems,\n          routerPanes,\n          resolvedPanes: paneDataItems.map((pane) => pane.pane),\n        }\n      }),\n    )\n\n    const subscription = resolvedPanes$.subscribe({\n      next: (result) => setData(result),\n      error: (e) => setError(e),\n    })\n\n    return () => subscription.unsubscribe()\n  }, [rootPaneNode, routerPanesStream, structureContext])\n\n  return data\n}\n","import {memo, useCallback, useEffect, useState} from 'react'\nimport {isRecord, useDocumentStore} from 'sanity'\nimport {useRouter, useRouterState} from 'sanity/router'\n\nimport {resolveIntent} from '../../../structureResolvers'\nimport {useStructureTool} from '../../../useStructureTool'\nimport {ensureDocumentIdAndType} from './utils'\n\nconst EMPTY_RECORD: Record<string, unknown> = {}\n\n/**\n * A component that receives an intent from props and redirects to the resolved\n * intent location (while showing a loading spinner during the process)\n */\nexport const IntentResolver = memo(function IntentResolver() {\n  const {navigate} = useRouter()\n  const maybeIntent = useRouterState(\n    useCallback((routerState) => {\n      const intentName = typeof routerState.intent === 'string' ? routerState.intent : undefined\n      return intentName\n        ? {\n            intent: intentName,\n            params: isRecord(routerState.params) ? routerState.params : EMPTY_RECORD,\n            payload: routerState.payload,\n          }\n        : undefined\n    }, []),\n  )\n  const {rootPaneNode, structureContext} = useStructureTool()\n  const documentStore = useDocumentStore()\n  const [error, setError] = useState<unknown>(null)\n\n  // this re-throws errors so that parent ErrorBoundary's can handle them properly\n  if (error) throw error\n\n  // eslint-disable-next-line consistent-return\n  useEffect(() => {\n    if (maybeIntent) {\n      const {intent, params, payload} = maybeIntent\n\n      let cancelled = false\n      // eslint-disable-next-line no-inner-declarations\n      async function effect() {\n        const {id, type} = await ensureDocumentIdAndType(\n          documentStore,\n          typeof params.id === 'string' ? params.id : undefined,\n          typeof params.type === 'string' ? params.type : undefined,\n        )\n\n        if (cancelled) return\n\n        const panes = await resolveIntent({\n          intent,\n          params: {...params, id, type},\n          payload,\n          rootPaneNode,\n          structureContext,\n        })\n\n        if (cancelled) return\n\n        navigate({panes}, {replace: true})\n      }\n\n      effect().catch(setError)\n\n      return () => {\n        cancelled = true\n      }\n    }\n  }, [documentStore, maybeIntent, navigate, rootPaneNode, structureContext])\n\n  return null\n})\n","import {uuid} from '@sanity/uuid'\nimport {firstValueFrom, type Observable} from 'rxjs'\nimport {type DocumentStore, getPublishedId} from 'sanity'\n\nimport {PaneResolutionError} from '../../../structureResolvers'\n\nexport function removeDraftPrefix(documentId: string): string {\n  const publishedId = getPublishedId(documentId)\n\n  if (publishedId !== documentId) {\n    console.warn(\n      'Removed unexpected draft id in document link: All links to documents should have the ' +\n        '`drafts.`-prefix removed and something appears to have made an intent link to `%s`',\n      documentId,\n    )\n  }\n\n  return publishedId\n}\n\nexport async function ensureDocumentIdAndType(\n  documentStore: DocumentStore,\n  id: string | undefined,\n  type: string | undefined,\n): Promise<{id: string; type: string}> {\n  if (id && type) return {id, type}\n  if (!id && type) return {id: uuid(), type}\n  if (id && !type) {\n    const resolvedType = await firstValueFrom(\n      documentStore.resolveTypeForDocument(id) as Observable<string>,\n    )\n\n    return {id, type: resolvedType}\n  }\n\n  throw new PaneResolutionError({\n    message: 'Neither document `id` or `type` was provided when trying to resolve intent.',\n  })\n}\n","import {omit} from 'lodash'\nimport {firstValueFrom, type Observable} from 'rxjs'\n\nimport {type StructureContext} from '../structureBuilder'\nimport {\n  type PaneNode,\n  type RouterPanes,\n  type RouterPaneSiblingContext,\n  type UnresolvedPaneNode,\n} from '../types'\nimport {assignId} from './assignId'\nimport {createPaneResolver, type PaneResolverMiddleware} from './createPaneResolver'\nimport {memoBind} from './memoBind'\n\ninterface TraverseOptions {\n  unresolvedPane: UnresolvedPaneNode | undefined\n  intent: string\n  params: {type: string; id: string; [key: string]: string | undefined}\n  payload: unknown\n  parent: PaneNode | null\n  path: string[]\n  currentId: string\n  flatIndex: number\n  levelIndex: number\n  structureContext: StructureContext\n}\n\nexport interface ResolveIntentOptions {\n  rootPaneNode?: UnresolvedPaneNode\n  intent: string\n  params: {type: string; id: string; [key: string]: string | undefined}\n  payload: unknown\n  structureContext: StructureContext\n}\n\n/**\n * Resolves an intent request using breadth first search. If a match is not\n * found, the intent will resolve to the fallback editor.\n *\n * A match is found if:\n * 1. the `PaneNode` is of type `document` and the its ID matches the intent ID\n * 2. the `PaneNode` is of type `documentList` and the `schemaTypeName` matches\n * 3. the `PaneNode`'s `canHandleIntent` method returns true\n *\n * If a `PaneNode` of type `list` is found, it will be searched for a match.\n *\n * @see PaneNode\n */\nexport async function resolveIntent(options: ResolveIntentOptions): Promise<RouterPanes> {\n  const resolvedPaneCache = new Map<string, Observable<PaneNode>>()\n\n  // this is a simple version of the memoizer in `createResolvedPaneNodeStream`\n  const memoize: PaneResolverMiddleware = (nextFn) => (unresolvedPane, context, flatIndex) => {\n    const key = unresolvedPane && `${assignId(unresolvedPane)}-${context.path.join('__')}`\n    const cachedResolvedPane = key && resolvedPaneCache.get(key)\n    if (cachedResolvedPane) return cachedResolvedPane\n\n    const result = nextFn(unresolvedPane, context, flatIndex)\n    if (key) resolvedPaneCache.set(key, result)\n    return result\n  }\n\n  const resolvePane = createPaneResolver(memoize)\n\n  const fallbackEditorPanes: RouterPanes = [\n    [\n      {\n        id: `__edit__${options.params.id}`,\n        params: {...omit(options.params, ['id']), type: options.params.type},\n        payload: options.payload,\n      },\n    ],\n  ]\n\n  async function traverse({\n    currentId,\n    flatIndex,\n    intent,\n    params,\n    parent,\n    path,\n    payload,\n    unresolvedPane,\n    levelIndex,\n    structureContext,\n  }: TraverseOptions): Promise<\n    Array<{panes: RouterPanes; depthIndex: number; levelIndex: number}>\n  > {\n    if (!unresolvedPane) return []\n\n    const {id: targetId, type: schemaTypeName, ...otherParams} = params\n    const context: RouterPaneSiblingContext = {\n      id: currentId,\n      splitIndex: 0,\n      parent,\n      path,\n      index: flatIndex,\n      params: {},\n      payload: undefined,\n      structureContext,\n    }\n    const resolvedPane = await firstValueFrom(resolvePane(unresolvedPane, context, flatIndex))\n\n    // if the resolved pane is a document pane and the pane's ID matches then\n    // resolve the intent to the current path\n    if (resolvedPane.type === 'document' && resolvedPane.id === targetId) {\n      return [\n        {\n          panes: [\n            ...path.slice(0, path.length - 1).map((i) => [{id: i}]),\n            [{id: targetId, params: otherParams, payload}],\n          ],\n          depthIndex: path.length,\n          levelIndex,\n        },\n      ]\n    }\n\n    // NOTE: if you update this logic, please also update the similar handler in\n    // `getIntentState.ts`\n    if (\n      // if the resolve pane's `canHandleIntent` returns true, then resolve\n      resolvedPane.canHandleIntent?.(intent, params, {\n        pane: resolvedPane,\n        index: flatIndex,\n      }) ||\n      // if the pane's `canHandleIntent` did not return true, then match against\n      // this default case. we will resolve the intent if:\n      (resolvedPane.type === 'documentList' &&\n        // 1. the schema type matches (this required for the document to render)\n        resolvedPane.schemaTypeName === schemaTypeName &&\n        // 2. the filter is the default filter.\n        //\n        // NOTE: this case is to prevent false positive matches where the user\n        // has configured a more specific filter for a particular type. In that\n        // case, the user can implement their own `canHandleIntent` function\n        resolvedPane.options.filter === '_type == $type')\n    ) {\n      return [\n        {\n          panes: [\n            // map the current path to router panes\n            ...path.map((id) => [{id}]),\n            // then augment with the intents IDs and params\n            [{id: params.id, params: otherParams, payload}],\n          ],\n          depthIndex: path.length,\n          levelIndex,\n        },\n      ]\n    }\n\n    if (resolvedPane.type === 'list' && resolvedPane.child && resolvedPane.items) {\n      return (\n        await Promise.all(\n          resolvedPane.items.map((item, nextLevelIndex) => {\n            if (item.type === 'divider') return Promise.resolve([])\n\n            return traverse({\n              currentId: item._id || item.id,\n              flatIndex: flatIndex + 1,\n              intent,\n              params,\n              parent: resolvedPane,\n              path: [...path, item.id],\n              payload,\n              unresolvedPane:\n                typeof resolvedPane.child === 'function'\n                  ? memoBind(resolvedPane, 'child')\n                  : resolvedPane.child,\n              levelIndex: nextLevelIndex,\n              structureContext,\n            })\n          }),\n        )\n      ).flat()\n    }\n\n    return []\n  }\n\n  const matchingPanes = await traverse({\n    currentId: 'root',\n    flatIndex: 0,\n    levelIndex: 0,\n    intent: options.intent,\n    params: options.params,\n    parent: null,\n    path: [],\n    payload: options.payload,\n    unresolvedPane: options.rootPaneNode,\n    structureContext: options.structureContext,\n  })\n\n  const closestPaneToRoot = matchingPanes.sort((a, b) => {\n    // break ties with the level index\n    if (a.depthIndex === b.depthIndex) return a.levelIndex - b.levelIndex\n    return a.depthIndex - b.depthIndex\n  })[0]\n\n  if (closestPaneToRoot) {\n    return closestPaneToRoot.panes\n  }\n\n  return fallbackEditorPanes\n}\n","import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {SyncIcon} from '@sanity/icons'\nimport {Box, Card, Code, Container, Heading, Stack, Text} from '@sanity/ui'\nimport {useCallback} from 'react'\nimport {useTranslation} from 'sanity'\nimport {styled} from 'styled-components'\n\nimport {Button} from '../../../ui-components'\nimport {structureLocaleNamespace} from '../../i18n'\nimport {SerializeError} from '../../structureBuilder'\nimport {PaneResolutionError} from '../../structureResolvers'\n\nconst PathSegment = styled.span`\n  &:not(:last-child)::after {\n    content: '  ';\n    opacity: 0.5;\n  }\n`\n\nfunction formatStack(stack: string) {\n  return (\n    stack\n      // Prettify builder functions\n      .replace(/\\(\\.\\.\\.\\)\\./g, '(...)\\n  .')\n      // Remove webpack cruft from function names\n      .replace(/__WEBPACK_IMPORTED_MODULE_\\d+_+/g, '')\n      // Remove default export postfix from function names\n      .replace(/___default\\./g, '.')\n      // Replace full host path, leave only path to JS-file\n      .replace(new RegExp(` \\\\(https?:\\\\/\\\\/${window.location.host}`, 'g'), ' (')\n  )\n}\n\ninterface StructureErrorProps {\n  error: unknown\n}\n\nexport function StructureError({error}: StructureErrorProps) {\n  if (!(error instanceof PaneResolutionError)) {\n    throw error\n  }\n  const {cause} = error\n  const {t} = useTranslation(structureLocaleNamespace)\n\n  // Serialize errors are well-formatted and should be readable, in these cases a stack trace is\n  // usually not helpful. Build errors in dev (with HMR) usually also contains a bunch of garbage\n  // instead of an actual error message, so make sure we show the message in these cases as well\n  const stack = cause?.stack || error.stack\n  const showStack =\n    stack && !(cause instanceof SerializeError) && !error.message.includes('Module build failed:')\n\n  const path = cause instanceof SerializeError ? cause.path : []\n  const helpId = (cause instanceof SerializeError && cause.helpId) || error.helpId\n\n  const handleReload = useCallback(() => {\n    window.location.reload()\n  }, [])\n\n  return (\n    <Card height=\"fill\" overflow=\"auto\" padding={4} sizing=\"border\" tone=\"critical\">\n      <Container>\n        <Heading as=\"h2\">{t('structure-error.header.text')}</Heading>\n\n        <Card marginTop={4} padding={4} radius={2} overflow=\"auto\" shadow={1} tone=\"inherit\">\n          {path.length > 0 && (\n            <Stack space={2}>\n              <Text size={1} weight=\"medium\">\n                {t('structure-error.structure-path.label')}\n              </Text>\n              <Code>\n                {/* TODO: it seems like the path is off by one and includes */}\n                {/* `root` twice  */}\n                {path.slice(1).map((segment, i) => (\n                  // eslint-disable-next-line react/no-array-index-key\n                  <PathSegment key={`${segment}-${i}`}>{segment}</PathSegment>\n                ))}\n              </Code>\n            </Stack>\n          )}\n\n          <Stack marginTop={4} space={2}>\n            <Text size={1} weight=\"medium\">\n              {t('structure-error.error.label')}\n            </Text>\n            <Code>{showStack ? formatStack(stack) : error.message}</Code>\n          </Stack>\n\n          {helpId && (\n            <Box marginTop={4}>\n              <Text>\n                <a href={generateHelpUrl(helpId)} rel=\"noopener noreferrer\" target=\"_blank\">\n                  {t('structure-error.docs-link.text')}\n                </a>\n              </Text>\n            </Box>\n          )}\n\n          <Box marginTop={4}>\n            <Button\n              text={t('structure-error.reload-button.text')}\n              icon={SyncIcon}\n              tone=\"primary\"\n              onClick={handleReload}\n            />\n          </Box>\n        </Card>\n      </Container>\n    </Card>\n  )\n}\n","import {Box, Text} from '@sanity/ui'\nimport {isRecord, Translate, useTranslation} from 'sanity'\n\nimport {Pane, PaneContent, PaneHeader} from '../../components/pane'\nimport {structureLocaleNamespace} from '../../i18n'\n\ninterface UnknownPaneProps {\n  isSelected: boolean\n  pane: unknown\n  paneKey: string\n}\n\n/**\n * @internal\n */\nexport function UnknownPane(props: UnknownPaneProps) {\n  const {isSelected, pane, paneKey} = props\n  const type = (isRecord(pane) && pane.type) || null\n  const {t} = useTranslation(structureLocaleNamespace)\n  return (\n    <Pane id={paneKey} selected={isSelected}>\n      <PaneHeader title={t('panes.unknown-pane-type.title')} />\n      <PaneContent>\n        <Box padding={4}>\n          {typeof type === 'string' ? (\n            <Text as=\"p\" muted>\n              <Translate\n                t={t}\n                i18nKey=\"panes.unknown-pane-type.unknown-type.text\"\n                values={{type}}\n              />\n            </Text>\n          ) : (\n            <Text as=\"p\" muted>\n              <Translate t={t} i18nKey=\"panes.unknown-pane-type.missing-type.text\" />\n            </Text>\n          )}\n        </Box>\n      </PaneContent>\n    </Pane>\n  )\n}\n","import {isEqual} from 'lodash'\nimport {lazy, memo, Suspense} from 'react'\n\nimport {PaneRouterProvider} from '../components/paneRouter'\nimport {type PaneNode} from '../types'\nimport {LoadingPane} from './loading'\nimport {UnknownPane} from './unknown'\n\ninterface StructureToolPaneProps {\n  active: boolean\n  childItemId: string | null\n  groupIndex: number\n  index: number\n  itemId: string\n  pane: PaneNode\n  paneKey: string\n  params: Record<string, string | undefined>\n  payload: unknown\n  path: string\n  selected: boolean\n  siblingIndex: number\n}\n\n// TODO: audit this creates separate chunks\nconst paneMap = {\n  component: lazy(() => import('./userComponent')),\n  document: lazy(() => import('./document/pane')),\n  documentList: lazy(() => import('./documentList/pane')),\n  list: lazy(() => import('./list')),\n}\n\n/**\n * NOTE: The same pane might appear multiple times (split pane), so use index as tiebreaker\n *\n * @internal\n */\nexport const StructureToolPane = memo(\n  function StructureToolPane(props: StructureToolPaneProps) {\n    const {\n      active,\n      childItemId,\n      groupIndex,\n      index,\n      itemId,\n      pane,\n      paneKey,\n      params,\n      payload,\n      path,\n      selected,\n      siblingIndex,\n    } = props\n\n    const PaneComponent = paneMap[pane.type] || UnknownPane\n\n    return (\n      <PaneRouterProvider\n        flatIndex={index}\n        index={groupIndex}\n        params={params}\n        payload={payload}\n        siblingIndex={siblingIndex}\n      >\n        <Suspense fallback={<LoadingPane paneKey={paneKey} path={path} selected={selected} />}>\n          <PaneComponent\n            childItemId={childItemId || ''}\n            index={index}\n            itemId={itemId}\n            isActive={active}\n            isSelected={selected}\n            paneKey={paneKey}\n            // @ts-expect-error TS doesn't know how to handle this intersection\n            pane={pane}\n          />\n        </Suspense>\n      </PaneRouterProvider>\n    )\n  },\n  (\n    {params: prevParams = {}, payload: prevPayload = null, ...prev},\n    {params: nextParams = {}, payload: nextPayload = null, ...next},\n  ) => {\n    // deeply compare these objects (it's okay, they're small)\n    if (!isEqual(prevParams, nextParams)) return false\n    if (!isEqual(prevPayload, nextPayload)) return false\n\n    const keys = new Set([...Object.keys(prev), ...Object.keys(next)]) as Set<\n      keyof typeof next | keyof typeof prev\n    >\n\n    // then shallow equal the rest\n    for (const key of keys) {\n      if (prev[key] !== next[key]) return false\n    }\n\n    return true\n  },\n)\n","import {WarningOutlineIcon} from '@sanity/icons'\nimport {Box, Card, Container, Flex, Stack, Text} from '@sanity/ui'\nimport {useTranslation} from 'sanity'\n\nimport {structureLocaleNamespace} from '../../i18n'\n\nexport function NoDocumentTypesScreen() {\n  const {t} = useTranslation(structureLocaleNamespace)\n\n  return (\n    <Card height=\"fill\">\n      <Flex align=\"center\" height=\"fill\" justify=\"center\" padding={4} sizing=\"border\">\n        <Container width={0}>\n          <Card padding={4} radius={2} shadow={1} tone=\"caution\">\n            <Flex>\n              <Box>\n                <Text size={1}>\n                  <WarningOutlineIcon />\n                </Text>\n              </Box>\n              <Stack flex={1} marginLeft={3} space={3}>\n                <Text as=\"h1\" size={1} weight=\"medium\">\n                  {t('no-document-types-screen.title')}\n                </Text>\n                <Text as=\"p\" muted size={1}>\n                  {t('no-document-types-screen.subtitle')}\n                </Text>\n                <Text as=\"p\" muted size={1}>\n                  <a\n                    href=\"https://www.sanity.io/docs/create-a-schema-and-configure-sanity-studio\"\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                  >\n                    {t('no-document-types-screen.link-text')}\n                  </a>\n                </Text>\n              </Stack>\n            </Flex>\n          </Card>\n        </Container>\n      </Flex>\n    </Card>\n  )\n}\n","import {type ObjectSchemaType} from '@sanity/types'\nimport {useEffect} from 'react'\nimport {\n  unstable_useValuePreview as useValuePreview,\n  useEditState,\n  useSchema,\n  useTranslation,\n} from 'sanity'\n\nimport {LOADING_PANE} from '../../constants'\nimport {structureLocaleNamespace} from '../../i18n'\nimport {type Panes} from '../../structureResolvers'\nimport {type DocumentPaneNode} from '../../types'\nimport {useStructureTool} from '../../useStructureTool'\n\ninterface StructureTitleProps {\n  resolvedPanes: Panes['resolvedPanes']\n}\n\nconst DocumentTitle = (props: {documentId: string; documentType: string}) => {\n  const {documentId, documentType} = props\n  const editState = useEditState(documentId, documentType)\n  const schema = useSchema()\n  const {t} = useTranslation(structureLocaleNamespace)\n  const isNewDocument = !editState?.published && !editState?.draft\n  const documentValue = editState?.draft || editState?.published\n  const schemaType = schema.get(documentType) as ObjectSchemaType | undefined\n\n  const {value, isLoading: previewValueIsLoading} = useValuePreview({\n    enabled: true,\n    schemaType,\n    value: documentValue,\n  })\n\n  const documentTitle = isNewDocument\n    ? t('browser-document-title.new-document', {\n        schemaType: schemaType?.title || schemaType?.name,\n      })\n    : value?.title || t('browser-document-title.untitled-document')\n\n  const settled = editState.ready && !previewValueIsLoading\n  const newTitle = useConstructDocumentTitle(documentTitle)\n  useEffect(() => {\n    if (!settled) return\n    // Set the title as the document title\n    document.title = newTitle\n  }, [documentTitle, settled, newTitle])\n\n  return null\n}\n\nconst PassthroughTitle = (props: {title?: string}) => {\n  const {title} = props\n  const newTitle = useConstructDocumentTitle(title)\n  useEffect(() => {\n    // Set the title as the document title\n    document.title = newTitle\n  }, [newTitle, title])\n  return null\n}\n\nexport const StructureTitle = (props: StructureTitleProps) => {\n  const {resolvedPanes} = props\n\n  if (!resolvedPanes?.length) return null\n\n  const lastPane = resolvedPanes[resolvedPanes.length - 1]\n\n  // If the last pane is loading, display the structure tool title only\n  if (isLoadingPane(lastPane)) {\n    return <PassthroughTitle />\n  }\n\n  // If the last pane is a document\n  if (isDocumentPane(lastPane)) {\n    // Passthrough the document pane's title, which may be defined in structure builder\n    if (lastPane?.title) {\n      return <PassthroughTitle title={lastPane.title} />\n    }\n\n    // Otherwise, display a `document.title` containing the resolved Sanity document title\n    return <DocumentTitle documentId={lastPane.options.id} documentType={lastPane.options.type} />\n  }\n\n  // Otherwise, display the last pane's title (if present)\n  return <PassthroughTitle title={lastPane?.title} />\n}\n\n/**\n * Construct a pipe delimited title containing `activeTitle` (if applicable) and the base structure title.\n *\n * @param activeTitle - Title of the first segment\n *\n * @returns A pipe delimited title in the format `${activeTitle} | %BASE_STRUCTURE_TITLE%`\n * or simply `%BASE_STRUCTURE_TITLE` if `activeTitle` is undefined.\n */\nfunction useConstructDocumentTitle(activeTitle?: string) {\n  const structureToolBaseTitle = useStructureTool().structureContext.title\n  return [activeTitle, structureToolBaseTitle].filter((title) => title).join(' | ')\n}\n\n// Type guards\nfunction isDocumentPane(pane: Panes['resolvedPanes'][number]): pane is DocumentPaneNode {\n  return pane !== LOADING_PANE && pane.type === 'document'\n}\n\nfunction isLoadingPane(pane: Panes['resolvedPanes'][number]): pane is typeof LOADING_PANE {\n  return pane === LOADING_PANE\n}\n","import {PortalProvider, useTheme, useToast} from '@sanity/ui'\nimport {isHotkey} from 'is-hotkey-esm'\nimport {Fragment, memo, useCallback, useEffect, useState} from 'react'\nimport {_isCustomDocumentTypeDefinition, useSchema} from 'sanity'\nimport {useRouterState} from 'sanity/router'\nimport {styled} from 'styled-components'\n\nimport {LOADING_PANE} from '../../constants'\nimport {LoadingPane, StructureToolPane} from '../../panes'\nimport {useResolvedPanes} from '../../structureResolvers'\nimport {type PaneNode} from '../../types'\nimport {useStructureTool} from '../../useStructureTool'\nimport {PaneLayout} from '../pane'\nimport {NoDocumentTypesScreen} from './NoDocumentTypesScreen'\nimport {StructureTitle} from './StructureTitle'\n\ninterface StructureToolProps {\n  onPaneChange: (panes: Array<PaneNode | typeof LOADING_PANE>) => void\n}\n\nconst StyledPaneLayout = styled(PaneLayout)`\n  min-height: 100%;\n  min-width: 320px;\n`\n\nconst isSaveHotkey = isHotkey('mod+s')\n\n/**\n * @internal\n */\nexport const StructureTool = memo(function StructureTool({onPaneChange}: StructureToolProps) {\n  const {push: pushToast} = useToast()\n  const schema = useSchema()\n  const {layoutCollapsed, setLayoutCollapsed} = useStructureTool()\n  const {paneDataItems, resolvedPanes} = useResolvedPanes()\n  // Intent resolving is processed by the sibling `<IntentResolver />` but it doesn't have a UI for indicating progress.\n  // We handle that here, so if there are only 1 pane (the root structure), and there's an intent state in the router, we need to show a placeholder LoadingPane until\n  // the structure is resolved and we know what panes to load/display\n  const isResolvingIntent = useRouterState(\n    useCallback((routerState) => typeof routerState.intent === 'string', []),\n  )\n  const {\n    sanity: {media},\n  } = useTheme()\n\n  const [portalElement, setPortalElement] = useState<HTMLDivElement | null>(null)\n\n  const handleRootCollapse = useCallback(() => setLayoutCollapsed(true), [setLayoutCollapsed])\n  const handleRootExpand = useCallback(() => setLayoutCollapsed(false), [setLayoutCollapsed])\n\n  useEffect(() => {\n    // we check for length before emitting here to skip the initial empty array\n    // state from the `useResolvedPanes` hook. there should always be a root\n    // pane emitted on subsequent emissions\n    if (resolvedPanes.length) {\n      onPaneChange(resolvedPanes)\n    }\n  }, [onPaneChange, resolvedPanes])\n\n  useEffect(() => {\n    const handleGlobalKeyDown = (event: KeyboardEvent) => {\n      // Prevent `Cmd+S`\n      if (isSaveHotkey(event)) {\n        event.preventDefault()\n\n        pushToast({\n          closable: true,\n          id: 'auto-save-message',\n          status: 'info',\n          title: 'Your work is automatically saved!',\n          duration: 4000,\n        })\n      }\n    }\n\n    window.addEventListener('keydown', handleGlobalKeyDown)\n    return () => window.removeEventListener('keydown', handleGlobalKeyDown)\n  }, [pushToast])\n\n  const hasDefinedDocumentTypes = schema._original?.types.some(_isCustomDocumentTypeDefinition)\n\n  if (!hasDefinedDocumentTypes) {\n    return <NoDocumentTypesScreen />\n  }\n\n  return (\n    <PortalProvider element={portalElement || null}>\n      <StyledPaneLayout\n        flex={1}\n        height={layoutCollapsed ? undefined : 'fill'}\n        minWidth={media[1]}\n        onCollapse={handleRootCollapse}\n        onExpand={handleRootExpand}\n      >\n        {paneDataItems.map(\n          ({\n            active,\n            childItemId,\n            groupIndex,\n            itemId,\n            key: paneKey,\n            pane,\n            index: paneIndex,\n            params: paneParams,\n            path,\n            payload,\n            siblingIndex,\n            selected,\n          }) => (\n            <Fragment key={`${pane === LOADING_PANE ? 'loading' : pane.type}-${paneIndex}`}>\n              {pane === LOADING_PANE ? (\n                <LoadingPane paneKey={paneKey} path={path} selected={selected} />\n              ) : (\n                <StructureToolPane\n                  active={active}\n                  groupIndex={groupIndex}\n                  index={paneIndex}\n                  pane={pane}\n                  childItemId={childItemId}\n                  itemId={itemId}\n                  paneKey={paneKey}\n                  params={paneParams}\n                  payload={payload}\n                  path={path}\n                  selected={selected}\n                  siblingIndex={siblingIndex}\n                />\n              )}\n            </Fragment>\n          ),\n        )}\n        {/* If there's just 1 pane (the root), or less, and we're resolving an intent then it's necessary to show */}\n        {/* a loading indicator as the intent resolving is async, could take a while and can also be interrupted/redirected */}\n        {paneDataItems.length <= 1 && isResolvingIntent && (\n          <LoadingPane paneKey=\"intent-resolver\" />\n        )}\n      </StyledPaneLayout>\n      <StructureTitle resolvedPanes={resolvedPanes} />\n      <div data-portal=\"\" ref={setPortalElement} />\n    </PortalProvider>\n  )\n})\n","import {ErrorBoundary} from '@sanity/ui'\nimport {useEffect, useState} from 'react'\nimport {SourceProvider, type Tool, useWorkspace} from 'sanity'\n\nimport {setActivePanes} from '../../getIntentState'\nimport {StructureToolProvider} from '../../StructureToolProvider'\nimport {type StructureToolOptions} from '../../types'\nimport {IntentResolver} from './intentResolver'\nimport {StructureError} from './StructureError'\nimport {StructureTool} from './StructureTool'\n\ninterface StructureToolBoundaryProps {\n  tool: Tool<StructureToolOptions>\n}\n\nexport function StructureToolBoundary({tool: {options}}: StructureToolBoundaryProps) {\n  const {unstable_sources: sources} = useWorkspace()\n  const [firstSource] = sources\n  const {source, defaultDocumentNode, structure} = options || {}\n\n  // Set active panes to blank on mount and unmount\n  useEffect(() => {\n    setActivePanes([])\n    return () => setActivePanes([])\n  }, [])\n\n  const [{error}, setError] = useState<{error: unknown}>({error: null})\n  // this re-throws if the error it catches is not a PaneResolutionError\n  if (error) return <StructureError error={error} />\n\n  return (\n    <ErrorBoundary onCatch={setError}>\n      <SourceProvider name={source || firstSource.name}>\n        <StructureToolProvider defaultDocumentNode={defaultDocumentNode} structure={structure}>\n          <StructureTool onPaneChange={setActivePanes} />\n          <IntentResolver />\n        </StructureToolProvider>\n      </SourceProvider>\n    </ErrorBoundary>\n  )\n}\n"],"names":["emptyArray","PaneRouterProvider","props","children","flatIndex","index","params","payload","siblingIndex","navigate","navigateIntent","resolvePathFromState","useRouter","routerState","useRouterState","panes","expand","usePaneLayout","routerPaneGroups","useMemo","lastPane","length","groupIndex","createNextRouterState","useCallback","modifier","currentGroup","nextGroup","nextPanes","slice","modifyCurrentGroup","nextRouterState","setTimeout","createPathWithParams","nextParams","siblings","item","setPayload","nextPayload","setParams","handleEditReference","_ref","id","parentRefPath","type","template","toString","ctx","hasGroupSiblings","groupLength","routerPanesState","ChildLink","BackLink","ReferenceChildLink","ParameterizedLink","replaceCurrent","opts","arguments","undefined","closeCurrent","filter","sibling","closeCurrentAndAfter","element","replace","duplicateCurrent","options","duplicatedItem","setView","viewId","restParams","omit","view","jsx","PaneRouterContext","Provider","value","PaneResolutionError","Error","constructor","_ref2","message","context","helpId","cause","super","__publicField","name","this","randomIdCache","WeakMap","assignId","obj","cachedValue","get","nanoid","set","isPromise","thing","then","isSerializable","isRecord","serialize","rethrowWithPaneResolutionErrors","next","unresolvedPane","e","wrapWithPublishReplay","pipe","publishReplay","refCount","createPaneResolver","middleware","resolvePane","isObservable","from","switchMap","result","of","bindCache","memoBind","methodKey","boundMethods","Map","bound2","method","concat","bound","bind","fallbackEditorChild","nodeId","structureContext","resolveDocumentNode","defaultDocumentBuilder","schemaType","documentId","initialValueTemplate","hashResolvedPaneMeta","meta","normalized","routerPaneSibling","path","paneNode","JSON","stringify","resolvePaneTree","_ref4","flattenedRouterPanes","parent","parent2","current","rest","splitIndex","resolvedPaneMeta","loadingPanes","map","i","restIndex","_","currentIndex","nextStream","startsWith","child","nextResolvedPanes","console","warn","generateHelpUrl","createResolvedPaneNodeStream","_ref5","routerPanesStream","rootPaneNode","initialCacheState","cacheKeysByFlatIndex","resolvedPaneCache","NEVER","rawRouterPanes","routerPanes","flatMap","routerPaneGroup","startWith","operate","source","subscriber","prev","hasPrev","subscribe","createOperatorSubscriber","p","_ref6","curr","prevValue","currValue","isEqual","diffIndex","scan","acc","beforeDiffIndex","afterDiffIndex","keysToKeep","Set","keySet","Array","keysToDelete","key","has","delete","nextFn","_a","_b","parentId","serializeOptionsIndex","serializeOptions","serializeOptionsPath","hashContext","cachedResolvedPane","cacheKeySet","add","_ref7","nextPane","prevPane","distinctUntilChanged","nextValue","useResolvedPanes","error","setError","useState","useStructureTool","data","setData","paneDataItems","resolvedPanes","routerStateSubject","ReplaySubject","routerPanes$","asObservable","_routerState","state","useEffect","useRouterPanesStream","subscription","reduce","groupsLen","pane","itemId","active","childItemId","LOADING_PANE","join","selected","unsubscribe","EMPTY_RECORD","IntentResolver","memo","maybeIntent","intentName","intent","documentStore","useDocumentStore","cancelled","async","effect","uuid","firstValueFrom","resolveTypeForDocument","ensureDocumentIdAndType","fallbackEditorPanes","closestPaneToRoot","traverse","_ref3","currentId","levelIndex","targetId","schemaTypeName","otherParams","resolvedPane","depthIndex","canHandleIntent","call","items","Promise","all","nextLevelIndex","resolve","_id","flat","sort","a","b","resolveIntent","catch","PathSegment","styled","span","_templateObject","_taggedTemplateLiteral","formatStack","stack","RegExp","window","location","host","StructureError","_ref8","t","useTranslation","structureLocaleNamespace","showStack","SerializeError","includes","handleReload","reload","Card","height","overflow","padding","sizing","tone","jsxs","Container","Heading","as","marginTop","radius","shadow","Stack","space","Text","size","weight","Code","segment","Box","href","rel","target","Button","text","icon","SyncIcon","onClick","UnknownPane","isSelected","paneKey","Pane","PaneHeader","title","PaneContent","muted","Translate","i18nKey","values","paneMap","component","lazy","document","n","documentList","list","StructureToolPane","PaneComponent","Suspense","fallback","LoadingPane","isActive","_ref9","_ref10","prevParams","prevPayload","keys","Object","NoDocumentTypesScreen","Flex","align","justify","width","WarningOutlineIcon","flex","marginLeft","DocumentTitle","documentType","editState","useEditState","schema","useSchema","isNewDocument","published","draft","documentValue","isLoading","previewValueIsLoading","unstable_useValuePreview","enabled","documentTitle","settled","ready","newTitle","useConstructDocumentTitle","PassthroughTitle","StructureTitle","isDocumentPane","activeTitle","StyledPaneLayout","PaneLayout","_templateObject2","isSaveHotkey","isHotkey","StructureTool","_ref11","onPaneChange","push","pushToast","useToast","layoutCollapsed","setLayoutCollapsed","isResolvingIntent","sanity","media","useTheme","portalElement","setPortalElement","handleRootCollapse","handleRootExpand","handleGlobalKeyDown","event","preventDefault","closable","status","duration","addEventListener","removeEventListener","_original","types","some","_isCustomDocumentTypeDefinition","PortalProvider","minWidth","onCollapse","onExpand","_ref12","paneIndex","paneParams","Fragment","ref","StructureToolBoundary","_ref13","tool","unstable_sources","sources","useWorkspace","firstSource","defaultDocumentNode","structure","setActivePanes","ErrorBoundary","onCatch","SourceProvider","StructureToolProvider"],"sourceRoot":""}